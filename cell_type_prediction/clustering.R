#--------------------------------------------------------------------
# Script Name:   clustering.R
# Description:   Create clustering data objects for graph production
# Author:        Brandon Monier, Qin Ma, Juan Xie, Anjun Ma
# Created:       2019-02-01 12:08:30
# Last Modified:
#--------------------------------------------------------------------

#--------------------------------------------------------------------
# Detailed Purpose:
#    The main purpose of this Rscript is to generate objects for
#    downstream clustering analyses.
#--------------------------------------------------------------------

# === Preamble ======================================================

## Load packages
library(igraph)
library(mclust)
library(MCL)
library(clues)
library(anocva)

## Load data
# meta <- read.csv("example_data/col-data-scrna.csv", header = TRUE)
RAW <- read.table("example_data/Yan_RPKM",header=T,sep="\t")   # expression data
CellNum  <- dim(RAW)[2]-1  # the number of cells
Graph <-read.csv('example_data/Yan_RPKM_graph.csv',header=T,sep=",")

## Parsing
names(Graph) <- c('Node1','Node2','weight')
G <- graph.data.frame(Graph,directed = FALSE)  # convert file into graph
A <- as_adjacency_matrix(G,type="both",attr="weight",names=TRUE,sparse=FALSE)  # convert graph into adjacency matrix
V_name <- rownames(A)   # the vertix
Covered <- length(V_name)  # the #of covered cells

## Generate adjacency matrix
meta <- data.frame(
    id = as.character(unique(as.character(Graph$Node1))),
    type = as.factor(
        sub(
            pattern = "_(.*)$",
            replacement = "",
            x = levels(Graph$Node1)
        )
    )
)
adjMat <- igraph::get.adjacency(
    graph = igraph::graph.edgelist(
        el = as.matrix(Graph[, 1:2]),
        directed = FALSE
    )
)
adjMat <- as.matrix(adjMat)
adjMat2 <- igraph::graph_from_incidence_matrix(adjMat)



# === Functions =====================================================

## MCL clustering on adjacency matrix
MCL_cs <-function(A){
    CLUST <-list()
    for (i in 1:100){
        CLUST[[i]] <-mcl(A,addLoops = FALSE,inflation =i,max.iter=200)
    }
    KK <- as.data.frame(do.call(rbind,lapply(CLUST,'[[',1)))  # extract the number of clusters
    CAN_I <-c(which(as.numeric(as.character(KK$V1))>=2))     # results that has more than 5 clusters
    tt <-as.numeric(as.character(KK$V1))
    tt <-sort(table(tt),decreasing=T)[1]
    Final_K <-as.numeric(names(tt))

    if (length(CAN_I)!=0){
        MATRIX <-rep(0,Covered)%o%rep(0,Covered)
        for (k in 1:length(CAN_I)){
            MCL_label <-CLUST[[CAN_I[k]]]$Cluster  # record the label
            ClusterNum <-unique(MCL_label)   # record the number of clusters
            TEMP <-rep(0,Covered)%o%rep(0,Covered)
            temp <-rep(0,Covered) %o% rep(0,length(ClusterNum))
            for (n in 1:length(ClusterNum)){
                index <-which(MCL_label==ClusterNum[n])
                temp[index,n] <-1
                TEMP <-TEMP+temp[,n]%o%temp[,n]
            }
            MATRIX <-MATRIX+TEMP
        }
        MATRIX <-MATRIX/length(CAN_I)
        rownames(MATRIX) <-colnames(MATRIX) <-rownames(A)
        hc <-hclust(dist(MATRIX))
        memb <-cutree(hc,k=Final_K)
        if (length(rownames(A)) ==CellNum){
            label <-memb
        }else{
            LEFT <-setdiff(names(RAW)[-1],V_name)
            LEFT_Cluster <-rep(Final_K+1,length(LEFT))
            df_cell_label <-data.frame(cell=c(names(memb),LEFT),cluster=c(memb,LEFT_Cluster),K=rep(Final_K+1,CellNum))
            label <-df_cell_label$cluster
        }
    }
    return(label)
}

## Spectral clustering on adjacency matrix, need provide the number of clusters
SC_cs <-function(A,K){
    sc <-spectralClustering(A,k=K)
    names(sc) <-rownames(A)
    if (length(rownames(A)) ==CellNum){
        label <-sc
    }else{
        LEFT <-setdiff(names(RAW)[-1],V_name)
        LEFT_Cluster <-rep(K+1,length(LEFT))
        df_cell_label <-data.frame(cell=c(names(sc),LEFT),cluster=c(sc,LEFT_Cluster),K=rep(K+1,CellNum))
        label <-df_cell_label$cluster
    }
return(label)
}

## users need to specify which clustering method they want to use
CLUSTERING <-function(A,K,method){
    if (method=='MCL_cs'){
        label <-MCL_cs(A)
        return(label)
    }else if (method =='SC_cs'){
        label <-SC_cs(A,K)
        return(label)
    }
}



# ==== Process ======================================================
labels <-CLUSTERING(A = A, method = 'MCL_cs') # get the predicted cell cluster labels
# or label <-CLUSTERING(A,7,'SC_cs')

## if you have some reference labels, you can calculate the ARI, RI, FM and JI
target <-read.table('example_data/Yan_cell_label.csv',header=T,sep=',')
head(target)
# judge if the cell names are consistent
aa <-names(labels)
bb <-target$Cell_type

# if consistent, continue to calculate ARI ect
if (identical(sort(aa),sort(as.character(bb)))=='TRUE') {
  sorted <-labels[match(target$Cell_type,names(labels))] # sort the predicted label

  ARI <-adjustedRandIndex(sorted,target$Cluster)
  RI <-adjustedRand(sorted,target$Cluster,randMethod='Rand')
  FM <-adjustedRand(sorted,target$Cluster,randMethod='FM')
  JI <-adjustedRand(sorted,target$Cluster,randMethod='Jaccard')
  df <-data.frame(ARI=ARI, RandIndex=RI,FolkesMallow=FM, Jaccard=JI)
  df
} else {
  print('Cell names is not consistent, please double check !')
}



